-- Code automatically generated by asn1scc tool
pragma Warnings (Off, "redundant with clause in body");
pragma Warnings (On, "redundant with clause in body");

pragma Warnings (Off, "use clause for type");
pragma Warnings (Off, "is already use-visible through previous use_type_clause at");
pragma Warnings (On, "use clause for type");
pragma Warnings (On, "is already use-visible through previous use_type_clause at");


PACKAGE BODY PUS_C with SPARK_Mode IS




pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccDmtNull_Equal(val1, val2: in asn1SccDmtNull)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccDmtNull_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccDmtNull_Init return asn1SccDmtNull
is
    val: asn1SccDmtNull;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccDmtNull_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccDmtNull_IsConstraintValid(val : in asn1SccDmtNull) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val = 0);
    ret.ErrorCode := (if ret.Success then 0 else ERR_DMTNULL);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccDmtNull_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccHeaderless_Telemetries_Equal(val1, val2: in asn1SccHeaderless_Telemetries)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccHeaderless_Telemetries_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccHeaderless_Telemetries_Init return asn1SccHeaderless_Telemetries
is
    val: asn1SccHeaderless_Telemetries;
begin
    val := asn1SccDmtNull_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHeaderless_Telemetries_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccHeaderless_Telemetries_IsConstraintValid(val : in asn1SccHeaderless_Telemetries) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccDmtNull_IsConstraintValid(val);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccHeaderless_Telemetries_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTYPE_ID_Equal(val1, val2: in asn1SccTYPE_ID)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTYPE_ID_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTYPE_ID_Init return asn1SccTYPE_ID
is
    val: asn1SccTYPE_ID;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTYPE_ID_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTYPE_ID_IsConstraintValid(val : in asn1SccTYPE_ID) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_TYPE_ID);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTYPE_ID_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccREQUEST_ID_Equal(val1, val2: in asn1SccREQUEST_ID)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccREQUEST_ID_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccREQUEST_ID_Init return asn1SccREQUEST_ID
is
    val: asn1SccREQUEST_ID;
begin
    val := asn1Sccrequest_id_switch_mode;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccREQUEST_ID_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccREQUEST_ID_IsConstraintValid(val : in asn1SccREQUEST_ID) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (((((((((val = asn1Sccrequest_id_switch_mode)) OR ((val = asn1Sccrequest_id_set_threshold_voltage)))) OR ((val = asn1Sccrequest_id_set_thermal_control_parameters)))) OR ((val = asn1Sccrequest_id_distribute_on_off_device_command)))) OR ((val = asn1Sccrequest_id_distribute_register_load_command)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_REQUEST_ID);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccREQUEST_ID_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_Equal(val1, val2: in asn1SccSuccessfulStartOfExecutionNotificationNotification_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.requestID = val2.requestID);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_Init return asn1SccSuccessfulStartOfExecutionNotificationNotification_Type
is
    val: asn1SccSuccessfulStartOfExecutionNotificationNotification_Type;
begin

    --set requestID 
    val.requestID := asn1SccREQUEST_ID_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_IsConstraintValid(val : in asn1SccSuccessfulStartOfExecutionNotificationNotification_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccREQUEST_ID_IsConstraintValid(val.requestID);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_Equal(val1, val2: in asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_Equal(val1.successfulStartOfExecutionNotificationNotification, val2.successfulStartOfExecutionNotificationNotification);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_Init return asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type
is
    val: asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type;
begin

    --set successfulStartOfExecutionNotificationNotification 
    val.successfulStartOfExecutionNotificationNotification := asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_IsConstraintValid(val : in asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccSuccessfulStartOfExecutionNotificationNotification_Type_IsConstraintValid(val.successfulStartOfExecutionNotificationNotification);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccFAILURE_NOTICE_CODE_Equal(val1, val2: in asn1SccFAILURE_NOTICE_CODE)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccFAILURE_NOTICE_CODE_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccFAILURE_NOTICE_CODE_Init return asn1SccFAILURE_NOTICE_CODE
is
    val: asn1SccFAILURE_NOTICE_CODE;
begin
    val := asn1Sccfailure_notice_code_invalid_address;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFAILURE_NOTICE_CODE_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccFAILURE_NOTICE_CODE_IsConstraintValid(val : in asn1SccFAILURE_NOTICE_CODE) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (((((val = asn1Sccfailure_notice_code_invalid_address)) OR ((val = asn1Sccfailure_notice_code_invalid_mode)))) OR ((val = asn1Sccfailure_notice_code_invalid_state)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_FAILURE_NOTICE_CODE);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccFAILURE_NOTICE_CODE_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccON_OFF_DEVICE_ADDRESS_Equal(val1, val2: in asn1SccON_OFF_DEVICE_ADDRESS)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccON_OFF_DEVICE_ADDRESS_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccON_OFF_DEVICE_ADDRESS_Init return asn1SccON_OFF_DEVICE_ADDRESS
is
    val: asn1SccON_OFF_DEVICE_ADDRESS;
begin
    val := asn1Sccon_off_device_address_display;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccON_OFF_DEVICE_ADDRESS_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccON_OFF_DEVICE_ADDRESS_IsConstraintValid(val : in asn1SccON_OFF_DEVICE_ADDRESS) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val = asn1Sccon_off_device_address_display);
    ret.ErrorCode := (if ret.Success then 0 else ERR_ON_OFF_DEVICE_ADDRESS);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccON_OFF_DEVICE_ADDRESS_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccDistributeAnOnoffDeviceCommand_Type_Equal(val1, val2: in asn1SccDistributeAnOnoffDeviceCommand_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.onOffDeviceAddress = val2.onOffDeviceAddress);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccDistributeAnOnoffDeviceCommand_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccDistributeAnOnoffDeviceCommand_Type_Init return asn1SccDistributeAnOnoffDeviceCommand_Type
is
    val: asn1SccDistributeAnOnoffDeviceCommand_Type;
begin

    --set onOffDeviceAddress 
    val.onOffDeviceAddress := asn1SccON_OFF_DEVICE_ADDRESS_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccDistributeAnOnoffDeviceCommand_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccDistributeAnOnoffDeviceCommand_Type_IsConstraintValid(val : in asn1SccDistributeAnOnoffDeviceCommand_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccON_OFF_DEVICE_ADDRESS_IsConstraintValid(val.onOffDeviceAddress);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccDistributeAnOnoffDeviceCommand_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand_Equal(val1, val2: in asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := asn1SccDistributeAnOnoffDeviceCommand_Type_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_Equal(val1, val2: in asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand_Equal(val1.instructionsToDistributeAnOnoffDeviceCommand, val2.instructionsToDistributeAnOnoffDeviceCommand);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand_Init return asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand
is
    val: asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4);
        val.Data(i1) := asn1SccDistributeAnOnoffDeviceCommand_Type_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand_Init;
function asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_Init return asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type
is
    val: asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type;
begin

    --set instructionsToDistributeAnOnoffDeviceCommand 
    val.instructionsToDistributeAnOnoffDeviceCommand := asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_instructionsToDistributeAnOnoffDeviceCommand_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_IsConstraintValid(val : in asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val.instructionsToDistributeAnOnoffDeviceCommand.Length <= 4);
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_2_1_DISTRIBUTEONOFFDEVICECOMMANDS_TYPE_INSTRUCTIONSTODISTRIBUTEANONOFFDEVICECOMMAND);
    if ret.Success then
        i1 := val.instructionsToDistributeAnOnoffDeviceCommand.Data'First;
        while ret.Success and i1 <= val.instructionsToDistributeAnOnoffDeviceCommand.Length loop
            pragma Loop_Invariant (i1 >= val.instructionsToDistributeAnOnoffDeviceCommand.Data'First and i1 <= val.instructionsToDistributeAnOnoffDeviceCommand.Length);
            ret := asn1SccDistributeAnOnoffDeviceCommand_Type_IsConstraintValid(val.instructionsToDistributeAnOnoffDeviceCommand.Data(i1));
            i1 := i1+1;
        end loop;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccREGISTER_ADDRESS_Equal(val1, val2: in asn1SccREGISTER_ADDRESS)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccREGISTER_ADDRESS_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccREGISTER_ADDRESS_Init return asn1SccREGISTER_ADDRESS
is
    val: asn1SccREGISTER_ADDRESS;
begin
    val := asn1Sccregister_address_display_data;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccREGISTER_ADDRESS_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccREGISTER_ADDRESS_IsConstraintValid(val : in asn1SccREGISTER_ADDRESS) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val = asn1Sccregister_address_display_data);
    ret.ErrorCode := (if ret.Success then 0 else ERR_REGISTER_ADDRESS);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccREGISTER_ADDRESS_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID_Equal(val1, val2: in asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID_Init return asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID
is
    val: asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID;
begin
    val := asn1Scchk_id_all;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID_IsConstraintValid(val : in asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val = asn1Scchk_id_all);
    ret.ErrorCode := (if ret.Success then 0 else ERR_HOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_STRUCTURE_ID_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccPI_COEFFICIENT_Equal(val1, val2: in asn1SccPI_COEFFICIENT)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccPI_COEFFICIENT_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccPI_COEFFICIENT_Init return asn1SccPI_COEFFICIENT
is
    val: asn1SccPI_COEFFICIENT;
begin
    val := 0.00000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccPI_COEFFICIENT_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccPI_COEFFICIENT_IsConstraintValid(val : in asn1SccPI_COEFFICIENT) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := ((-1.00000000000000000000E+002 <= val) AND (val <= 1.00000000000000000000E+002));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PI_COEFFICIENT);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccPI_COEFFICIENT_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccUINT8T_Equal(val1, val2: in asn1SccUINT8T)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccUINT8T_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccUINT8T_Init return asn1SccUINT8T
is
    val: asn1SccUINT8T;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccUINT8T_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccUINT8T_IsConstraintValid(val : in asn1SccUINT8T) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val <= 255);
    ret.ErrorCode := (if ret.Success then 0 else ERR_UINT8T);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccUINT8T_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccREGISTER_DATA_Equal(val1, val2: in asn1SccREGISTER_DATA)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when register_address_display_data_PRESENT =>
                ret := (val1.register_address_display_data = val2.register_address_display_data);
        end case;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccREGISTER_DATA_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccREGISTER_DATA_Init return asn1SccREGISTER_DATA
is
    val: asn1SccREGISTER_DATA;
begin
    --set register_address_display_data 
    declare
        register_address_display_data_tmp:asn1SccUINT8T;
    begin
        register_address_display_data_tmp := asn1SccUINT8T_Init;
    	pragma Warnings (Off, "object ""register_address_display_data_tmp"" is always False at this point");
        val := asn1SccREGISTER_DATA'(kind => register_address_display_data_PRESENT, register_address_display_data => register_address_display_data_tmp);
    	pragma Warnings (On, "object ""register_address_display_data_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccREGISTER_DATA_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccREGISTER_DATA_IsConstraintValid(val : in asn1SccREGISTER_DATA) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    if val.kind = register_address_display_data_PRESENT then
    	ret := asn1SccUINT8T_IsConstraintValid(val.register_address_display_data);
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccREGISTER_DATA_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccDistributeARegisterLoadCommand_Type_Equal(val1, val2: in asn1SccDistributeARegisterLoadCommand_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccREGISTER_DATA_Equal(val1.registerData, val2.registerData);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccDistributeARegisterLoadCommand_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccDistributeARegisterLoadCommand_Type_Init return asn1SccDistributeARegisterLoadCommand_Type
is
    val: asn1SccDistributeARegisterLoadCommand_Type;
begin

    --set registerData 
    val.registerData := asn1SccREGISTER_DATA_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccDistributeARegisterLoadCommand_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccDistributeARegisterLoadCommand_Type_IsConstraintValid(val : in asn1SccDistributeARegisterLoadCommand_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccREGISTER_DATA_IsConstraintValid(val.registerData);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccDistributeARegisterLoadCommand_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand_Equal(val1, val2: in asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := asn1SccDistributeARegisterLoadCommand_Type_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_Equal(val1, val2: in asn1SccTC_2_2_DistributeRegisterLoadCommands_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand_Equal(val1.instructionsToDistributeARegisterLoadCommand, val2.instructionsToDistributeARegisterLoadCommand);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand_Init return asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand
is
    val: asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4);
        val.Data(i1) := asn1SccDistributeARegisterLoadCommand_Type_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand_Init;
function asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_Init return asn1SccTC_2_2_DistributeRegisterLoadCommands_Type
is
    val: asn1SccTC_2_2_DistributeRegisterLoadCommands_Type;
begin

    --set instructionsToDistributeARegisterLoadCommand 
    val.instructionsToDistributeARegisterLoadCommand := asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_instructionsToDistributeARegisterLoadCommand_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_IsConstraintValid(val : in asn1SccTC_2_2_DistributeRegisterLoadCommands_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val.instructionsToDistributeARegisterLoadCommand.Length <= 4);
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_2_2_DISTRIBUTEREGISTERLOADCOMMANDS_TYPE_INSTRUCTIONSTODISTRIBUTEAREGISTERLOADCOMMAND);
    if ret.Success then
        i1 := val.instructionsToDistributeARegisterLoadCommand.Data'First;
        while ret.Success and i1 <= val.instructionsToDistributeARegisterLoadCommand.Length loop
            pragma Loop_Invariant (i1 >= val.instructionsToDistributeARegisterLoadCommand.Data'First and i1 <= val.instructionsToDistributeARegisterLoadCommand.Length);
            ret := asn1SccDistributeARegisterLoadCommand_Type_IsConstraintValid(val.instructionsToDistributeARegisterLoadCommand.Data(i1));
            i1 := i1+1;
        end loop;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccDUTY_CYCLE_Equal(val1, val2: in asn1SccDUTY_CYCLE)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccDUTY_CYCLE_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccDUTY_CYCLE_Init return asn1SccDUTY_CYCLE
is
    val: asn1SccDUTY_CYCLE;
begin
    val := 0.00000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccDUTY_CYCLE_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccDUTY_CYCLE_IsConstraintValid(val : in asn1SccDUTY_CYCLE) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+000));
    ret.ErrorCode := (if ret.Success then 0 else ERR_DUTY_CYCLE);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccDUTY_CYCLE_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccSATELLITE_MODE_Equal(val1, val2: in asn1SccSATELLITE_MODE)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccSATELLITE_MODE_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccSATELLITE_MODE_Init return asn1SccSATELLITE_MODE
is
    val: asn1SccSATELLITE_MODE;
begin
    val := asn1Sccsatellite_mode_safe;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSATELLITE_MODE_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccSATELLITE_MODE_IsConstraintValid(val : in asn1SccSATELLITE_MODE) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (((((val = asn1Sccsatellite_mode_safe)) OR ((val = asn1Sccsatellite_mode_idle)))) OR ((val = asn1Sccsatellite_mode_operational)));
    ret.ErrorCode := (if ret.Success then 0 else ERR_SATELLITE_MODE);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccSATELLITE_MODE_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccSwitchMode_Type_Equal(val1, val2: in asn1SccSwitchMode_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.mode = val2.mode);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccSwitchMode_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccSwitchMode_Type_Init return asn1SccSwitchMode_Type
is
    val: asn1SccSwitchMode_Type;
begin

    --set mode 
    val.mode := asn1SccSATELLITE_MODE_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSwitchMode_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccSwitchMode_Type_IsConstraintValid(val : in asn1SccSwitchMode_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccSATELLITE_MODE_IsConstraintValid(val.mode);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccSwitchMode_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_222_1_SwitchMode_Type_Equal(val1, val2: in asn1SccTC_222_1_SwitchMode_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccSwitchMode_Type_Equal(val1.instructionToSwitchMode, val2.instructionToSwitchMode);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_222_1_SwitchMode_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_222_1_SwitchMode_Type_Init return asn1SccTC_222_1_SwitchMode_Type
is
    val: asn1SccTC_222_1_SwitchMode_Type;
begin

    --set instructionToSwitchMode 
    val.instructionToSwitchMode := asn1SccSwitchMode_Type_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_222_1_SwitchMode_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_222_1_SwitchMode_Type_IsConstraintValid(val : in asn1SccTC_222_1_SwitchMode_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccSwitchMode_Type_IsConstraintValid(val.instructionToSwitchMode);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_222_1_SwitchMode_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccVOLTAGE_Equal(val1, val2: in asn1SccVOLTAGE)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccVOLTAGE_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccVOLTAGE_Init return asn1SccVOLTAGE
is
    val: asn1SccVOLTAGE;
begin
    val := 0.00000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccVOLTAGE_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccVOLTAGE_IsConstraintValid(val : in asn1SccVOLTAGE) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+002));
    ret.ErrorCode := (if ret.Success then 0 else ERR_VOLTAGE);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccVOLTAGE_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address_Equal(val1, val2: in asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode_Equal(val1, val2: in asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.mode = val2.mode);

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.input_voltage, val2.input_voltage));

    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state_Equal(val1, val2: in asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccFAILURE_NOTICE_DATA_Equal(val1, val2: in asn1SccFAILURE_NOTICE_DATA)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when failure_notice_code_invalid_address_PRESENT =>
                ret := asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address_Equal(val1.failure_notice_code_invalid_address, val2.failure_notice_code_invalid_address);
            when failure_notice_code_invalid_mode_PRESENT =>
                ret := asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode_Equal(val1.failure_notice_code_invalid_mode, val2.failure_notice_code_invalid_mode);
            when failure_notice_code_invalid_state_PRESENT =>
                ret := asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state_Equal(val1.failure_notice_code_invalid_state, val2.failure_notice_code_invalid_state);
        end case;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccFAILURE_NOTICE_DATA_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address_Init return asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address
is
    val: asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address;
begin
    val := asn1Sccinvalid_address;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address_Init;
function asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode_Init return asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode
is
    val: asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode;
begin

    --set mode 
    val.mode := asn1SccSATELLITE_MODE_Init;
    --set input_voltage 
    val.input_voltage := asn1SccVOLTAGE_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_mode_Init;
function asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state_Init return asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state
is
    val: asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state;
begin
    val := asn1Sccdisabled;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_state_Init;
function asn1SccFAILURE_NOTICE_DATA_Init return asn1SccFAILURE_NOTICE_DATA
is
    val: asn1SccFAILURE_NOTICE_DATA;
begin
    --set failure_notice_code_invalid_address 
    declare
        failure_notice_code_invalid_address_tmp:asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address;
    begin
        failure_notice_code_invalid_address_tmp := asn1SccFAILURE_NOTICE_DATA_failure_notice_code_invalid_address_Init;
    	pragma Warnings (Off, "object ""failure_notice_code_invalid_address_tmp"" is always False at this point");
        val := asn1SccFAILURE_NOTICE_DATA'(kind => failure_notice_code_invalid_address_PRESENT, failure_notice_code_invalid_address => failure_notice_code_invalid_address_tmp);
    	pragma Warnings (On, "object ""failure_notice_code_invalid_address_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFAILURE_NOTICE_DATA_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccFAILURE_NOTICE_DATA_IsConstraintValid(val : in asn1SccFAILURE_NOTICE_DATA) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    if val.kind = failure_notice_code_invalid_address_PRESENT then
    	ret.Success := (val.failure_notice_code_invalid_address = asn1Sccinvalid_address);
    	ret.ErrorCode := (if ret.Success then 0 else ERR_FAILURE_NOTICE_DATA_FAILURE_NOTICE_CODE_INVALID_ADDRESS);
    end if;
    if ret.Success then
        if val.kind = failure_notice_code_invalid_mode_PRESENT then
        	ret := asn1SccSATELLITE_MODE_IsConstraintValid(val.failure_notice_code_invalid_mode.mode);
        	if ret.Success then
        	    ret := asn1SccVOLTAGE_IsConstraintValid(val.failure_notice_code_invalid_mode.input_voltage);
        	end if;
        end if;
        if ret.Success then
            if val.kind = failure_notice_code_invalid_state_PRESENT then
            	ret.Success := (val.failure_notice_code_invalid_state = asn1Sccdisabled);
            	ret.ErrorCode := (if ret.Success then 0 else ERR_FAILURE_NOTICE_DATA_FAILURE_NOTICE_CODE_INVALID_STATE);
            end if;
        end if;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccFAILURE_NOTICE_DATA_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccFailedStartOfExecutionNotificationNotification_Type_Equal(val1, val2: in asn1SccFailedStartOfExecutionNotificationNotification_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.requestID = val2.requestID);

    if ret then
        ret := asn1SccFAILURE_NOTICE_DATA_Equal(val1.failureNoticeData, val2.failureNoticeData);

    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccFailedStartOfExecutionNotificationNotification_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccFailedStartOfExecutionNotificationNotification_Type_Init return asn1SccFailedStartOfExecutionNotificationNotification_Type
is
    val: asn1SccFailedStartOfExecutionNotificationNotification_Type;
begin

    --set requestID 
    val.requestID := asn1SccREQUEST_ID_Init;
    --set failureNoticeData 
    val.failureNoticeData := asn1SccFAILURE_NOTICE_DATA_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccFailedStartOfExecutionNotificationNotification_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccFailedStartOfExecutionNotificationNotification_Type_IsConstraintValid(val : in asn1SccFailedStartOfExecutionNotificationNotification_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccREQUEST_ID_IsConstraintValid(val.requestID);
    if ret.Success then
        ret := asn1SccFAILURE_NOTICE_DATA_IsConstraintValid(val.failureNoticeData);
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccFailedStartOfExecutionNotificationNotification_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_Equal(val1, val2: in asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccFailedStartOfExecutionNotificationNotification_Type_Equal(val1.failedStartOfExecutionNotificationNotification, val2.failedStartOfExecutionNotificationNotification);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_Init return asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type
is
    val: asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type;
begin

    --set failedStartOfExecutionNotificationNotification 
    val.failedStartOfExecutionNotificationNotification := asn1SccFailedStartOfExecutionNotificationNotification_Type_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_IsConstraintValid(val : in asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccFailedStartOfExecutionNotificationNotification_Type_IsConstraintValid(val.failedStartOfExecutionNotificationNotification);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccSetSafeThresholdVoltage_Type_Equal(val1, val2: in asn1SccSetSafeThresholdVoltage_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (adaasn1rtl.Asn1Real_Equal(val1.threshold_voltage, val2.threshold_voltage));

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccSetSafeThresholdVoltage_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccSetSafeThresholdVoltage_Type_Init return asn1SccSetSafeThresholdVoltage_Type
is
    val: asn1SccSetSafeThresholdVoltage_Type;
begin

    --set threshold_voltage 
    val.threshold_voltage := asn1SccVOLTAGE_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSetSafeThresholdVoltage_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccSetSafeThresholdVoltage_Type_IsConstraintValid(val : in asn1SccSetSafeThresholdVoltage_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccVOLTAGE_IsConstraintValid(val.threshold_voltage);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccSetSafeThresholdVoltage_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_222_11_SetSafeThresholdVoltage_Type_Equal(val1, val2: in asn1SccTC_222_11_SetSafeThresholdVoltage_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccSetSafeThresholdVoltage_Type_Equal(val1.instructionToSetSafeThresholdVoltage, val2.instructionToSetSafeThresholdVoltage);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_222_11_SetSafeThresholdVoltage_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_222_11_SetSafeThresholdVoltage_Type_Init return asn1SccTC_222_11_SetSafeThresholdVoltage_Type
is
    val: asn1SccTC_222_11_SetSafeThresholdVoltage_Type;
begin

    --set instructionToSetSafeThresholdVoltage 
    val.instructionToSetSafeThresholdVoltage := asn1SccSetSafeThresholdVoltage_Type_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_222_11_SetSafeThresholdVoltage_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_222_11_SetSafeThresholdVoltage_Type_IsConstraintValid(val : in asn1SccTC_222_11_SetSafeThresholdVoltage_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccSetSafeThresholdVoltage_Type_IsConstraintValid(val.instructionToSetSafeThresholdVoltage);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_222_11_SetSafeThresholdVoltage_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTEMPERATURE_Equal(val1, val2: in asn1SccTEMPERATURE)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTEMPERATURE_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTEMPERATURE_Init return asn1SccTEMPERATURE
is
    val: asn1SccTEMPERATURE;
begin
    val := 0.00000000000000000000E+000;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTEMPERATURE_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTEMPERATURE_IsConstraintValid(val : in asn1SccTEMPERATURE) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := ((-1.00000000000000000000E+002 <= val) AND (val <= 1.00000000000000000000E+002));
    ret.ErrorCode := (if ret.Success then 0 else ERR_TEMPERATURE);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTEMPERATURE_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all_Equal(val1, val2: in asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (val1.mode = val2.mode);

    if ret then
        ret := (val1.thermal_enabled = val2.thermal_enabled);

        if ret then
            ret := (val1.payload_enabled = val2.payload_enabled);

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.input_voltage, val2.input_voltage));

                if ret then
                    ret := (adaasn1rtl.Asn1Real_Equal(val1.current_temperature, val2.current_temperature));

                    if ret then
                        ret := (adaasn1rtl.Asn1Real_Equal(val1.target_temperature, val2.target_temperature));

                        if ret then
                            ret := (adaasn1rtl.Asn1Real_Equal(val1.pi_integral, val2.pi_integral));

                            if ret then
                                ret := (adaasn1rtl.Asn1Real_Equal(val1.thermal_duty_cycle, val2.thermal_duty_cycle));

                                if ret then
                                    ret := (val1.payload_data_enabled = val2.payload_data_enabled);

                                    if ret then
                                        ret := (val1.payload_data = val2.payload_data);

                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_Equal(val1, val2: in asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when hk_id_all_PRESENT =>
                ret := asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all_Equal(val1.hk_id_all, val2.hk_id_all);
        end case;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all_Init return asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all
is
    val: asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all;
begin

    --set mode 
    val.mode := asn1SccSATELLITE_MODE_Init;
    --set thermal_enabled 
    val.thermal_enabled := FALSE;
    --set payload_enabled 
    val.payload_enabled := FALSE;
    --set input_voltage 
    val.input_voltage := asn1SccVOLTAGE_Init;
    --set current_temperature 
    val.current_temperature := asn1SccTEMPERATURE_Init;
    --set target_temperature 
    val.target_temperature := asn1SccTEMPERATURE_Init;
    --set pi_integral 
    val.pi_integral := asn1SccPI_COEFFICIENT_Init;
    --set thermal_duty_cycle 
    val.thermal_duty_cycle := asn1SccDUTY_CYCLE_Init;
    --set payload_data_enabled 
    val.payload_data_enabled := FALSE;
    --set payload_data 
    val.payload_data := asn1SccUINT8T_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all_Init;
function asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_Init return asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA
is
    val: asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA;
begin
    --set hk_id_all 
    declare
        hk_id_all_tmp:asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all;
    begin
        hk_id_all_tmp := asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_hk_id_all_Init;
    	pragma Warnings (Off, "object ""hk_id_all_tmp"" is always False at this point");
        val := asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA'(kind => hk_id_all_PRESENT, hk_id_all => hk_id_all_tmp);
    	pragma Warnings (On, "object ""hk_id_all_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_IsConstraintValid(val : in asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    if val.kind = hk_id_all_PRESENT then
    	ret := asn1SccSATELLITE_MODE_IsConstraintValid(val.hk_id_all.mode);
    	if ret.Success then
    	    ret := asn1SccVOLTAGE_IsConstraintValid(val.hk_id_all.input_voltage);
    	    if ret.Success then
    	        ret := asn1SccTEMPERATURE_IsConstraintValid(val.hk_id_all.current_temperature);
    	        if ret.Success then
    	            ret := asn1SccTEMPERATURE_IsConstraintValid(val.hk_id_all.target_temperature);
    	            if ret.Success then
    	                ret := asn1SccPI_COEFFICIENT_IsConstraintValid(val.hk_id_all.pi_integral);
    	                if ret.Success then
    	                    ret := asn1SccDUTY_CYCLE_IsConstraintValid(val.hk_id_all.thermal_duty_cycle);
    	                    if ret.Success then
    	                        ret := asn1SccUINT8T_IsConstraintValid(val.hk_id_all.payload_data);
    	                    end if;
    	                end if;
    	            end if;
    	        end if;
    	    end if;
    	end if;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccHousekeepingParameterNotificationNotification_Type_Equal(val1, val2: in asn1SccHousekeepingParameterNotificationNotification_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_Equal(val1.data, val2.data);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccHousekeepingParameterNotificationNotification_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccHousekeepingParameterNotificationNotification_Type_Init return asn1SccHousekeepingParameterNotificationNotification_Type
is
    val: asn1SccHousekeepingParameterNotificationNotification_Type;
begin

    --set data 
    val.data := asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccHousekeepingParameterNotificationNotification_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccHousekeepingParameterNotificationNotification_Type_IsConstraintValid(val : in asn1SccHousekeepingParameterNotificationNotification_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccHOUSEKEEPING_PARAMETER_REPORT_DATA_IsConstraintValid(val.data);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccHousekeepingParameterNotificationNotification_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTM_3_25_HousekeepingParameterReport_Type_Equal(val1, val2: in asn1SccTM_3_25_HousekeepingParameterReport_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccHousekeepingParameterNotificationNotification_Type_Equal(val1.housekeepingParameterNotificationNotification, val2.housekeepingParameterNotificationNotification);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTM_3_25_HousekeepingParameterReport_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTM_3_25_HousekeepingParameterReport_Type_Init return asn1SccTM_3_25_HousekeepingParameterReport_Type
is
    val: asn1SccTM_3_25_HousekeepingParameterReport_Type;
begin

    --set housekeepingParameterNotificationNotification 
    val.housekeepingParameterNotificationNotification := asn1SccHousekeepingParameterNotificationNotification_Type_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTM_3_25_HousekeepingParameterReport_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTM_3_25_HousekeepingParameterReport_Type_IsConstraintValid(val : in asn1SccTM_3_25_HousekeepingParameterReport_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccHousekeepingParameterNotificationNotification_Type_IsConstraintValid(val.housekeepingParameterNotificationNotification);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTM_3_25_HousekeepingParameterReport_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccRegular_Telemetries_Equal(val1, val2: in asn1SccRegular_Telemetries)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when tm_1_3_successfulStartOfExecutionVerificationReport_PRESENT =>
                ret := asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_Equal(val1.tm_1_3_successfulStartOfExecutionVerificationReport, val2.tm_1_3_successfulStartOfExecutionVerificationReport);
            when tm_1_4_failedStartOfExecutionVerificationReport_PRESENT =>
                ret := asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_Equal(val1.tm_1_4_failedStartOfExecutionVerificationReport, val2.tm_1_4_failedStartOfExecutionVerificationReport);
            when tm_3_25_housekeepingParameterReport_PRESENT =>
                ret := asn1SccTM_3_25_HousekeepingParameterReport_Type_Equal(val1.tm_3_25_housekeepingParameterReport, val2.tm_3_25_housekeepingParameterReport);
        end case;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccRegular_Telemetries_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccRegular_Telemetries_Init return asn1SccRegular_Telemetries
is
    val: asn1SccRegular_Telemetries;
begin
    --set tm_1_3_successfulStartOfExecutionVerificationReport 
    declare
        tm_1_3_successfulStartOfExecutionVerificationReport_tmp:asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type;
    begin
        tm_1_3_successfulStartOfExecutionVerificationReport_tmp := asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_Init;
    	pragma Warnings (Off, "object ""tm_1_3_successfulStartOfExecutionVerificationReport_tmp"" is always False at this point");
        val := asn1SccRegular_Telemetries'(kind => tm_1_3_successfulStartOfExecutionVerificationReport_PRESENT, tm_1_3_successfulStartOfExecutionVerificationReport => tm_1_3_successfulStartOfExecutionVerificationReport_tmp);
    	pragma Warnings (On, "object ""tm_1_3_successfulStartOfExecutionVerificationReport_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccRegular_Telemetries_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccRegular_Telemetries_IsConstraintValid(val : in asn1SccRegular_Telemetries) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    if val.kind = tm_1_3_successfulStartOfExecutionVerificationReport_PRESENT then
    	ret := asn1SccTM_1_3_SuccessfulStartOfExecutionVerificationReport_Type_IsConstraintValid(val.tm_1_3_successfulStartOfExecutionVerificationReport);
    end if;
    if ret.Success then
        if val.kind = tm_1_4_failedStartOfExecutionVerificationReport_PRESENT then
        	ret := asn1SccTM_1_4_FailedStartOfExecutionVerificationReport_Type_IsConstraintValid(val.tm_1_4_failedStartOfExecutionVerificationReport);
        end if;
        if ret.Success then
            if val.kind = tm_3_25_housekeepingParameterReport_PRESENT then
            	ret := asn1SccTM_3_25_HousekeepingParameterReport_Type_IsConstraintValid(val.tm_3_25_housekeepingParameterReport);
            end if;
        end if;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccRegular_Telemetries_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTelemetry_Equal(val1, val2: in asn1SccTelemetry)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccRegular_Telemetries_Equal(val1.packet_data, val2.packet_data);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTelemetry_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTelemetry_Init return asn1SccTelemetry
is
    val: asn1SccTelemetry;
begin

    --set packet_data 
    val.packet_data := asn1SccRegular_Telemetries_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTelemetry_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTelemetry_IsConstraintValid(val : in asn1SccTelemetry) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccRegular_Telemetries_IsConstraintValid(val.packet_data);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTelemetry_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccSetThermalControlParameters_Type_Equal(val1, val2: in asn1SccSetThermalControlParameters_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := (adaasn1rtl.Asn1Real_Equal(val1.target_temperature, val2.target_temperature));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.kp, val2.kp));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.ki, val2.ki));

        end if;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccSetThermalControlParameters_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccSetThermalControlParameters_Type_Init return asn1SccSetThermalControlParameters_Type
is
    val: asn1SccSetThermalControlParameters_Type;
begin

    --set target_temperature 
    val.target_temperature := asn1SccTEMPERATURE_Init;
    --set kp 
    val.kp := asn1SccPI_COEFFICIENT_Init;
    --set ki 
    val.ki := asn1SccPI_COEFFICIENT_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccSetThermalControlParameters_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccSetThermalControlParameters_Type_IsConstraintValid(val : in asn1SccSetThermalControlParameters_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccTEMPERATURE_IsConstraintValid(val.target_temperature);
    if ret.Success then
        ret := asn1SccPI_COEFFICIENT_IsConstraintValid(val.kp);
        if ret.Success then
            ret := asn1SccPI_COEFFICIENT_IsConstraintValid(val.ki);
        end if;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccSetThermalControlParameters_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_222_21_SetThermalControlParameters_Type_Equal(val1, val2: in asn1SccTC_222_21_SetThermalControlParameters_Type)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccSetThermalControlParameters_Type_Equal(val1.instructionToSetThermalControlParameters, val2.instructionToSetThermalControlParameters);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_222_21_SetThermalControlParameters_Type_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_222_21_SetThermalControlParameters_Type_Init return asn1SccTC_222_21_SetThermalControlParameters_Type
is
    val: asn1SccTC_222_21_SetThermalControlParameters_Type;
begin

    --set instructionToSetThermalControlParameters 
    val.instructionToSetThermalControlParameters := asn1SccSetThermalControlParameters_Type_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_222_21_SetThermalControlParameters_Type_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_222_21_SetThermalControlParameters_Type_IsConstraintValid(val : in asn1SccTC_222_21_SetThermalControlParameters_Type) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccSetThermalControlParameters_Type_IsConstraintValid(val.instructionToSetThermalControlParameters);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_222_21_SetThermalControlParameters_Type_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTelecommands_Equal(val1, val2: in asn1SccTelecommands)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when tc_2_1_distributeOnoffDeviceCommands_PRESENT =>
                ret := asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_Equal(val1.tc_2_1_distributeOnoffDeviceCommands, val2.tc_2_1_distributeOnoffDeviceCommands);
            when tc_2_2_distributeRegisterLoadCommands_PRESENT =>
                ret := asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_Equal(val1.tc_2_2_distributeRegisterLoadCommands, val2.tc_2_2_distributeRegisterLoadCommands);
            when tc_222_1_switchMode_PRESENT =>
                ret := asn1SccTC_222_1_SwitchMode_Type_Equal(val1.tc_222_1_switchMode, val2.tc_222_1_switchMode);
            when tc_222_11_setSafeThresholdVoltage_PRESENT =>
                ret := asn1SccTC_222_11_SetSafeThresholdVoltage_Type_Equal(val1.tc_222_11_setSafeThresholdVoltage, val2.tc_222_11_setSafeThresholdVoltage);
            when tc_222_21_setThermalControlParameters_PRESENT =>
                ret := asn1SccTC_222_21_SetThermalControlParameters_Type_Equal(val1.tc_222_21_setThermalControlParameters, val2.tc_222_21_setThermalControlParameters);
        end case;
    end if;
	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTelecommands_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTelecommands_Init return asn1SccTelecommands
is
    val: asn1SccTelecommands;
begin
    --set tc_2_1_distributeOnoffDeviceCommands 
    declare
        tc_2_1_distributeOnoffDeviceCommands_tmp:asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type;
    begin
        tc_2_1_distributeOnoffDeviceCommands_tmp := asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_Init;
    	pragma Warnings (Off, "object ""tc_2_1_distributeOnoffDeviceCommands_tmp"" is always False at this point");
        val := asn1SccTelecommands'(kind => tc_2_1_distributeOnoffDeviceCommands_PRESENT, tc_2_1_distributeOnoffDeviceCommands => tc_2_1_distributeOnoffDeviceCommands_tmp);
    	pragma Warnings (On, "object ""tc_2_1_distributeOnoffDeviceCommands_tmp"" is always False at this point");
    end;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTelecommands_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTelecommands_IsConstraintValid(val : in asn1SccTelecommands) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    if val.kind = tc_2_1_distributeOnoffDeviceCommands_PRESENT then
    	ret := asn1SccTC_2_1_DistributeOnoffDeviceCommands_Type_IsConstraintValid(val.tc_2_1_distributeOnoffDeviceCommands);
    end if;
    if ret.Success then
        if val.kind = tc_2_2_distributeRegisterLoadCommands_PRESENT then
        	ret := asn1SccTC_2_2_DistributeRegisterLoadCommands_Type_IsConstraintValid(val.tc_2_2_distributeRegisterLoadCommands);
        end if;
        if ret.Success then
            if val.kind = tc_222_1_switchMode_PRESENT then
            	ret := asn1SccTC_222_1_SwitchMode_Type_IsConstraintValid(val.tc_222_1_switchMode);
            end if;
            if ret.Success then
                if val.kind = tc_222_11_setSafeThresholdVoltage_PRESENT then
                	ret := asn1SccTC_222_11_SetSafeThresholdVoltage_Type_IsConstraintValid(val.tc_222_11_setSafeThresholdVoltage);
                end if;
                if ret.Success then
                    if val.kind = tc_222_21_setThermalControlParameters_PRESENT then
                    	ret := asn1SccTC_222_21_SetThermalControlParameters_Type_IsConstraintValid(val.tc_222_21_setThermalControlParameters);
                    end if;
                end if;
            end if;
        end if;
    end if;
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTelecommands_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTelecommand_Equal(val1, val2: in asn1SccTelecommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
    ret := asn1SccTelecommands_Equal(val1.packet_data, val2.packet_data);

	return ret;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTelecommand_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTelecommand_Init return asn1SccTelecommand
is
    val: asn1SccTelecommand;
begin

    --set packet_data 
    val.packet_data := asn1SccTelecommands_Init;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTelecommand_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTelecommand_IsConstraintValid(val : in asn1SccTelecommand) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret := asn1SccTelecommands_IsConstraintValid(val.packet_data);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTelecommand_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_2_1_COUNT_Equal(val1, val2: in asn1SccTC_2_1_COUNT)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_2_1_COUNT_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_2_1_COUNT_Init return asn1SccTC_2_1_COUNT
is
    val: asn1SccTC_2_1_COUNT;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_2_1_COUNT_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_2_1_COUNT_IsConstraintValid(val : in asn1SccTC_2_1_COUNT) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val <= 4);
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_2_1_COUNT);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_2_1_COUNT_IsConstraintValid;



pragma Warnings (Off, "formal parameter ""val1"" is not referenced");
pragma Warnings (Off, "formal parameter ""val2"" is not referenced");
function asn1SccTC_2_2_COUNT_Equal(val1, val2: in asn1SccTC_2_2_COUNT)
    return Boolean 
is
begin
    pragma Warnings (Off, "condition can only be False if invalid values present");        
    pragma Warnings (Off, "condition can only be True if invalid values present");        
	return val1 = val2;

    pragma Warnings (On, "condition can only be False if invalid values present");        
    pragma Warnings (On, "condition can only be True if invalid values present");        
end asn1SccTC_2_2_COUNT_Equal;
pragma Warnings (On, "formal parameter ""val1"" is not referenced");
pragma Warnings (On, "formal parameter ""val2"" is not referenced");

function asn1SccTC_2_2_COUNT_Init return asn1SccTC_2_2_COUNT
is
    val: asn1SccTC_2_2_COUNT;
begin
    val := 0;
	pragma Warnings (Off, "object ""val"" is always");
    return val;
	pragma Warnings (On, "object ""val"" is always");
end asn1SccTC_2_2_COUNT_Init;

	pragma Warnings (Off, "formal parameter ""val"" is not referenced");
function asn1SccTC_2_2_COUNT_IsConstraintValid(val : in asn1SccTC_2_2_COUNT) return adaasn1rtl.ASN1_RESULT
is
	pragma Warnings (On, "formal parameter ""val"" is not referenced");
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
begin
	pragma Warnings (Off, "condition can only be False if invalid values present");
	pragma Warnings (Off, "condition can only be True if invalid values present");
    ret.Success := (val <= 4);
    ret.ErrorCode := (if ret.Success then 0 else ERR_TC_2_2_COUNT);
	pragma Warnings (On, "condition can only be False if invalid values present");
	pragma Warnings (On, "condition can only be True if invalid values present");
    return ret;
end asn1SccTC_2_2_COUNT_IsConstraintValid;


 

END PUS_C;